# -*- coding: utf-8 -*-
"""Analisador de Sequências FASTA

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/15X6rXJpb7jRglZvVltvQC3MihBg8ShoQ
"""

# -*- coding: utf-8 -*-
#"""
#"""
#DNA Sequence Analysis Program

#This program analyzes DNA sequences from a multi-FASTA file and answers
#four biological questions related to the dataset.

#The program uses the Biopython library for FASTA parsing.

#Implemented analyses:
#1. Count the total number of records in the FASTA file.
#2. Determine the longest and shortest sequences.
#3. Identify the longest Open Reading Frame (ORF) in each reading frame.
#4. Find the most frequent repeated subsequence of length n.

#Author: Társio Chiconi
#"""
#"""

from Bio import SeqIO
from collections import defaultdict

# --- Funções de Análise ---

def question1_record_count(records):
    """
    (1) Conta o número total de registros no arquivo FASTA.
    """
    return len(records)

def question2_sequence_lengths(records):
    """
    (2) Analisa os comprimentos de todas as sequências, encontrando a mais longa e a mais curta.
    Retorna um dicionário com os resultados.
    """
    if not records:
        return {
            "all_lengths": {},
            "longest_len": 0,
            "longest_ids": [],
            "shortest_len": 0,
            "shortest_ids": []
        }

    lengths = {rec.id: len(rec.seq) for rec in records}

    max_len = -1
    min_len = float('inf')

    # Encontra o comprimento máximo e mínimo
    for length in lengths.values():
        if length > max_len:
            max_len = length
        if length < min_len:
            min_len = length

    # Encontra todos os identificadores que correspondem aos comprimentos máximo e mínimo (caso haja empates)
    longest_ids = [rec_id for rec_id, length in lengths.items() if length == max_len]
    shortest_ids = [rec_id for rec_id, length in lengths.items() if length == min_len]

    return {
        "all_lengths": lengths,
        "longest_len": max_len,
        "longest_ids": longest_ids,
        "shortest_len": min_len,
        "shortest_ids": shortest_ids
    }

def find_orfs_in_sequence(sequence, frame):
    """
    Função auxiliar para encontrar todas as ORFs em uma única sequência para um determinado quadro de leitura.
    Retorna uma lista de tuplas (comprimento, posição_inicial).
    """
    orfs = []
    start_codon = "ATG"
    stop_codons = ["TAA", "TAG", "TGA"]

    # Ajusta a sequência para o quadro de leitura especificado
    # frame 1 -> índice 0, frame 2 -> índice 1, frame 3 -> índice 2
    seq_in_frame = sequence[frame - 1:]

    i = 0
    while i < len(seq_in_frame):
        codon = seq_in_frame[i:i+3]

        # Procura por um códon de início
        if codon == start_codon:
            start_pos_in_frame = i

            # Uma vez que um códon de início é encontrado, procura por um códon de parada
            j = i + 3
            while j < len(seq_in_frame):
                stop_codon = seq_in_frame[j:j+3]
                if stop_codon in stop_codons:
                    # ORF encontrada. Calcula o comprimento e a posição inicial real.
                    orf_len = (j + 3) - start_pos_in_frame
                    # A posição é 1-based, então +1
                    start_pos_real = start_pos_in_frame + frame
                    orfs.append((orf_len, start_pos_real))
                    # Move o índice principal para depois desta ORF para evitar sobreposição de inícios
                    i = j
                    break
                j += 3
        i += 3

    return orfs

def question3_orfs(records, frame):
    """
    (3) Encontra a ORF mais longa em um determinado quadro de leitura em todas as sequências.
    """
    longest_orf_len = 0
    longest_orf_id = None
    longest_orf_start_pos = -1
    orfs_by_id = defaultdict(list)

    for rec in records:
        found_orfs = find_orfs_in_sequence(rec.seq, frame)
        if found_orfs:
            orfs_by_id[rec.id].extend(found_orfs)

    # Encontra a ORF mais longa em todo o arquivo
    for rec_id, orf_list in orfs_by_id.items():
        if not orf_list:
            continue

        current_max_orf = max(orf_list, key=lambda item: item[0])
        if current_max_orf[0] > longest_orf_len:
            longest_orf_len = current_max_orf[0]
            longest_orf_id = rec_id
            longest_orf_start_pos = current_max_orf[1]

    return {
        "frame": frame,
        "longest_orf_len": longest_orf_len,
        "longest_orf_id": longest_orf_id,
        "longest_orf_start_pos": longest_orf_start_pos,
        "all_orfs_by_id": orfs_by_id
    }

def question4_repeats(records, n):
    """
    (4) Encontra a repetição mais frequente de um determinado comprimento n.
    """
    counts = defaultdict(int)

    for rec in records:
        sequence = str(rec.seq)
        if len(sequence) >= n:
            for i in range(len(sequence) - n + 1):
                repeat = sequence[i:i+n]
                counts[repeat] += 1

    # Filtra para incluir apenas sequências que se repetem (contagem > 1)
    repeats = {seq: count for seq, count in counts.items() if count > 1}

    if not repeats:
        return {
            "length": n,
            "most_frequent_repeat": None,
            "frequency": 0,
            "all_repeats": {}
        }

    # Encontra a repetição mais frequente
    most_frequent_repeat = max(repeats, key=repeats.get)
    frequency = repeats[most_frequent_repeat]

    return {
        "length": n,
        "most_frequent_repeat": most_frequent_repeat,
        "frequency": frequency,
        "all_repeats": repeats
    }

# --- Bloco Principal de Execução ---

def main(filename):
    """
    Função principal que executa todas as análises no arquivo FASTA fornecido.
    """
    try:
        # Lê e armazena todos os registros em memória.
        # Para arquivos muito grandes, seria melhor iterar sem armazenar tudo.
        records = list(SeqIO.parse(filename, "fasta"))
        print(f"Análise do arquivo: {filename}\n{'='*40}\n")
    except FileNotFoundError:
        print(f"Erro: O arquivo '{filename}' não foi encontrado.")
        return
    except Exception as e:
        print(f"Ocorreu um erro ao processar o arquivo: {e}")
        return

    # --- Resposta para a Pergunta 1 ---
    count = question1_record_count(records)
    print(f"--- Pergunta 1: Contagem de Registros ---\n")
    print(f"Total de registros no arquivo: {count}\n")

    # --- Resposta para a Pergunta 2 ---
    length_results = question2_sequence_lengths(records)
    print(f"--- Pergunta 2: Comprimento das Sequências ---\n")
    print(f"Sequência mais longa: {length_results['longest_len']} pb")
    print(f"  Identificador(es): {', '.join(length_results['longest_ids'])}\n")
    print(f"Sequência mais curta: {length_results['shortest_len']} pb")
    print(f"  Identificador(es): {', '.join(length_results['shortest_ids'])}\n")

    # --- Resposta para a Pergunta 3 ---
    print(f"--- Pergunta 3: Quadros de Leitura Abertos (ORFs) ---\n")
    # Analisa os três quadros de leitura na fita direta
    for frame_to_check in [1, 2, 3]:
        orf_results = question3_orfs(records, frame_to_check)
        print(f"Para o quadro de leitura {orf_results['frame']}:")
        if orf_results['longest_orf_id']:
            print(f"  - Comprimento da ORF mais longa: {orf_results['longest_orf_len']} pb")
            print(f"  - Identificador da sequência: {orf_results['longest_orf_id']}")
            print(f"  - Posição inicial: {orf_results['longest_orf_start_pos']}\n")
        else:
            print(f"  - Nenhuma ORF encontrada neste quadro de leitura.\n")

    # Exemplo de como obter a ORF mais longa para um ID específico
    specific_id = "gi|142022655|gb|EQ086233.1|41" # Exemplo do arquivo dna.example.fasta
    orf_results_frame1 = question3_orfs(records, 1)
    orfs_in_specific_seq = orf_results_frame1['all_orfs_by_id'].get(specific_id, [])
    if orfs_in_specific_seq:
        longest_in_seq = max(orfs_in_specific_seq, key=lambda item: item[0])
        print(f"Exemplo de análise de ORF específica:")
        print(f"ORF mais longa para '{specific_id}' no quadro 1: {longest_in_seq[0]} pb, iniciando em {longest_in_seq[1]}\n")


    # --- Resposta para a Pergunta 4 ---
    print(f"--- Pergunta 4: Repetições Frequentes ---\n")
    # O senhor pode alterar o valor de 'repeat_length_to_check' para o que for solicitado no exame.
    repeat_length_to_check = 12
    repeat_results = question4_repeats(records, repeat_length_to_check)
    print(f"Para repetições de comprimento {repeat_results['length']}:")
    if repeat_results['most_frequent_repeat']:
        print(f"  - Repetição mais frequente: '{repeat_results['most_frequent_repeat']}'")
        print(f"  - Frequência: {repeat_results['frequency']} vezes\n")
    else:
        print(f"  - Nenhuma repetição encontrada com este comprimento.\n")


if __name__ == "__main__":
    # NOME DO ARQUIVO DE ENTRADA.
    # ALTERE ESTE VALOR PARA O NOME DO ARQUIVO DO EXAME.
    fasta_file = "dna.example.fasta"
    main(fasta_file)

